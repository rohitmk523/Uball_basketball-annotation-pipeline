# Basketball Training Pipeline V4 - Cloud Run Jobs (Parallel Execution)
# Uses Cloud Run Jobs instead of Cloud Functions for true parallel processing

main:
  params: [args]
  steps:
    - init:
        assign:
          - game_ids: ${args.game_ids}
          - project_id: "refined-circuit-474617-s8"
          - region: "us-central1"
          - timestamp: ${string(int(sys.now()))}
          - execution_dir: ${"cumulative-execution-" + timestamp}
          - base_model: "gemini-2.5-pro"
          - model_prefix: "basketball-pro"
          - job_name: "extract-clips-job"

    - log_start:
        call: sys.log
        args:
          data: '${"ðŸš€ Starting cumulative training for " + string(len(game_ids)) + " games using Cloud Run Jobs"}'
          severity: INFO

    # Step 1: Trigger Cloud Run Jobs for all games in parallel
    - trigger_all_games:
        parallel:
          for:
            value: game_id
            in: ${game_ids}
            steps:
              - log_trigger_start:
                  call: sys.log
                  args:
                    data: '${"ðŸš€ Triggering Cloud Run Job for game: " + game_id}'
                    severity: INFO

              - trigger_job:
                  try:
                    call: http.post
                    args:
                      url: '${"https://run.googleapis.com/v2/projects/" + project_id + "/locations/" + region + "/jobs/" + job_name + ":run"}'
                      auth:
                        type: OAuth2
                      headers:
                        Content-Type: "application/json"
                      body:
                        overrides:
                          containerOverrides:
                            - env:
                                - name: GAME_ID
                                  value: ${game_id}
                    result: job_execution
                  except:
                    as: e
                    steps:
                      - log_trigger_error:
                          call: sys.log
                          args:
                            data: '${"âš ï¸ Failed to trigger job for game " + game_id + ": " + e.message}'
                            severity: WARNING
                          next: continue

              - log_triggered:
                  call: sys.log
                  args:
                    data: '${"âœ… Cloud Run Job triggered for game: " + game_id + " (Execution: " + job_execution.body.name + ")"}'
                    severity: INFO

    - log_all_triggered:
        call: sys.log
        args:
          data: "âœ… All Cloud Run Jobs triggered! Now polling for completion..."
          severity: INFO

    # Step 2: Poll for completion by checking JSONL files in GCS
    - wait_for_all_games:
        call: poll_games_completion
        args:
          game_ids: ${game_ids}
          max_wait_minutes: 360

    - log_extraction_complete:
        call: sys.log
        args:
          data: "ðŸŽ‰ All games processed! Starting JSONL combination..."
          severity: INFO

    # Step 3: Combine JSONL files using Cloud Function (simple and reliable)
    - call_combine_function:
        call: http.post
        args:
          url: "https://us-central1-refined-circuit-474617-s8.cloudfunctions.net/combine-jsonl"
          headers:
            Content-Type: "application/json"
          body:
            game_ids: ${game_ids}
            execution_dir: ${execution_dir}
        result: combine_result

    - log_combine_complete:
        call: sys.log
        args:
          data: '${"âœ… Combined JSONL files: " + string(combine_result.body.training_examples) + " training examples, " + string(combine_result.body.validation_examples) + " validation examples"}'
          severity: INFO

    # Step 4: Start Vertex AI tuning
    - set_file_paths:
        assign:
          - training_file: '${"gs://uball-training-data/" + execution_dir + "/combined_training.jsonl"}'
          - validation_file: '${"gs://uball-training-data/" + execution_dir + "/combined_validation.jsonl"}'

    - create_tuning_job:
        call: http.post
        args:
          url: '${"https://" + region + "-aiplatform.googleapis.com/v1/projects/" + project_id + "/locations/" + region + "/tuningJobs"}'
          auth:
            type: OAuth2
          headers:
            Content-Type: "application/json"
          body:
            baseModel: ${base_model}
            supervisedTuningSpec:
              trainingDatasetUri: ${training_file}
              validationDatasetUri: ${validation_file}
              hyperParameters:
                epochCount: "5"
                learningRateMultiplier: "1.0"
                adapterSize: "ADAPTER_SIZE_ONE"
            tunedModelDisplayName: '${"" + model_prefix + "-cumulative-" + string(len(game_ids)) + "games-" + timestamp}'
            description: '${"Cumulative training on " + string(len(game_ids)) + " games using " + base_model}'
        result: tuning_response

    - log_tuning_started:
        call: sys.log
        args:
          data: '${"ðŸ¤– Started tuning job: " + tuning_response.body.name}'
          severity: INFO

    - wait_tuning:
        call: monitor_tuning
        args:
          job_name: ${tuning_response.body.name}

    - log_success:
        call: sys.log
        args:
          data: '${"ðŸŽ‰ Cumulative training completed for " + string(len(game_ids)) + " games!"}'
          severity: INFO

    - return_result:
        return:
          success: true
          games_trained: ${game_ids}
          total_games: ${len(game_ids)}
          training_file: ${training_file}
          validation_file: ${validation_file}
          execution_directory: ${execution_dir}

# Poll for game completion by checking GCS for JSONL files
poll_games_completion:
  params: [game_ids, max_wait_minutes]
  steps:
    - init_polling:
        assign:
          - completed_games: []
          - check_interval_seconds: 30
          - max_checks: ${max_wait_minutes * 2}
          - current_check: 0

    - poll_loop:
        steps:
          - increment_check:
              assign:
                - current_check: ${current_check + 1}

          - log_polling:
              call: sys.log
              args:
                data: '${"ðŸ” Polling check " + string(current_check) + "/" + string(max_checks) + " | Completed: " + string(len(completed_games)) + "/" + string(len(game_ids))}'
                severity: INFO

          - check_each_game:
              for:
                value: game_id
                in: ${game_ids}
                steps:
                  - skip_if_completed:
                      switch:
                        - condition: ${game_id in completed_games}
                          next: continue

                  - check_game_files:
                      try:
                        call: http.get
                        args:
                          url: '${"https://storage.googleapis.com/storage/v1/b/uball-training-data/o?prefix=games%2F" + game_id + "%2Fvideo_training_"}'
                          auth:
                            type: OAuth2
                        result: files_check
                      except:
                        as: e
                        steps:
                          - assign_empty_result:
                              assign:
                                - files_check:
                                    body:
                                      items: []

                  - evaluate_completion:
                      switch:
                        - condition: ${"items" in files_check.body and len(files_check.body.items) > 0}
                          steps:
                            - mark_complete:
                                assign:
                                  - completed_games: ${list.concat(completed_games, game_id)}
                            - log_game_complete:
                                call: sys.log
                                args:
                                  data: '${"âœ… Game completed: " + game_id}'
                                  severity: INFO

          - check_all_complete:
              switch:
                - condition: ${len(completed_games) == len(game_ids)}
                  steps:
                    - log_all_complete:
                        call: sys.log
                        args:
                          data: '${"ðŸŽ‰ All " + string(len(game_ids)) + " games completed!"}'
                          severity: INFO
                    - return_success:
                        return:
                          success: true
                          completed_games: ${completed_games}

          - check_timeout:
              switch:
                - condition: ${current_check >= max_checks}
                  steps:
                    - log_timeout:
                        call: sys.log
                        args:
                          data: '${"âš ï¸ Timeout after " + string(max_wait_minutes) + " minutes. Completed: " + string(len(completed_games)) + "/" + string(len(game_ids))}'
                          severity: WARNING
                    - raise_timeout:
                        raise: '${"Timeout waiting for games. Completed: " + string(len(completed_games)) + "/" + string(len(game_ids))}'

          - wait_before_retry:
              call: sys.sleep
              args:
                seconds: ${check_interval_seconds}

          - next_iteration:
              next: poll_loop

# Wait for Cloud Run job completion (v2 API)
wait_job_complete_v2:
  params: [execution_name]
  steps:
    - init_polling:
        assign:
          - iterations: 0
          - max_iterations: 120

    - poll_loop:
        steps:
          - check_status:
              call: http.get
              args:
                url: '${"https://run.googleapis.com/v2/" + execution_name}'
                auth:
                  type: OAuth2
              result: execution_status

          - check_completion:
              switch:
                - condition: ${"completionTime" in execution_status.body}
                  steps:
                    - log_completed:
                        call: sys.log
                        args:
                          data: "âœ… Job execution completed successfully"
                          severity: INFO
                    - return_completed:
                        return: ${execution_status}
                - condition: ${iterations >= max_iterations}
                  raise: "Execution timed out after 1 hour"

          - log_still_running:
              call: sys.log
              args:
                data: '${"â³ Job execution still running (iteration " + string(iterations) + ")"}'
                severity: INFO

          - wait_and_retry:
              call: sys.sleep
              args:
                seconds: 30

          - increment_iterations:
              assign:
                - iterations: ${iterations + 1}
              next: poll_loop

# Monitor Vertex AI tuning job
monitor_tuning:
  params: [job_name]
  steps:
    - poll_loop:
        assign:
          - iterations: 0
          - max_iterations: 480
    - check_tuning:
        call: http.get
        args:
          url: '${"https://us-central1-aiplatform.googleapis.com/v1/" + job_name}'
          auth:
            type: OAuth2
        result: tuning_status
    - evaluate_tuning:
        switch:
          - condition: ${tuning_status.body.state == "JOB_STATE_SUCCEEDED"}
            return:
              success: true
              tuned_model: ${tuning_status.body.tunedModel.model}
          - condition: ${tuning_status.body.state == "JOB_STATE_FAILED"}
            raise: '${"Tuning failed: " + tuning_status.body.error.message}'
          - condition: ${iterations >= max_iterations}
            raise: "Tuning timed out"
    - wait_and_retry:
        call: sys.sleep
        args:
          seconds: 60
    - increment_and_continue:
        assign:
          - iterations: ${iterations + 1}
        next: check_tuning

